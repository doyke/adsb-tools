// Code generated by protoc-gen-gogo.
// source: proto/adsb.proto
// DO NOT EDIT!

/*
	Package adsb is a generated protocol buffer package.

	It is generated from these files:
		proto/adsb.proto

	It has these top-level messages:
		AdsbHeader
		AdsbPacket
		Adsb
		AdsbStream
*/
package adsb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import bytes "bytes"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AdsbHeader struct {
	// Always "aDsB"
	Magic string `protobuf:"bytes,1,req,name=magic" json:"magic"`
	// Unique identifier for this server implementation
	// Recommended: "https://url/of/source#version"
	ServerVersion string `protobuf:"bytes,2,req,name=server_version" json:"server_version"`
	// Unique identifier for this server instance
	// UUID recommended
	// 36 character limit
	ServerId string `protobuf:"bytes,3,req,name=server_id" json:"server_id"`
	// MHz of the clock used in subsequent mlat_timestamp fields
	MlatTimestampMhz uint32 `protobuf:"fixed32,4,req,name=mlat_timestamp_mhz" json:"mlat_timestamp_mhz"`
	// Maximum value of subsequent mlat_timestamp fields, at which point values are expected to wrap
	MlatTimestampMax uint64 `protobuf:"fixed64,5,req,name=mlat_timestamp_max" json:"mlat_timestamp_max"`
	// Maximum value of subsequent rssi fields
	RssiMax uint32 `protobuf:"fixed32,6,req,name=rssi_max" json:"rssi_max"`
}

func (m *AdsbHeader) Reset()      { *m = AdsbHeader{} }
func (*AdsbHeader) ProtoMessage() {}

func (m *AdsbHeader) GetMagic() string {
	if m != nil {
		return m.Magic
	}
	return ""
}

func (m *AdsbHeader) GetServerVersion() string {
	if m != nil {
		return m.ServerVersion
	}
	return ""
}

func (m *AdsbHeader) GetServerId() string {
	if m != nil {
		return m.ServerId
	}
	return ""
}

func (m *AdsbHeader) GetMlatTimestampMhz() uint32 {
	if m != nil {
		return m.MlatTimestampMhz
	}
	return 0
}

func (m *AdsbHeader) GetMlatTimestampMax() uint64 {
	if m != nil {
		return m.MlatTimestampMax
	}
	return 0
}

func (m *AdsbHeader) GetRssiMax() uint32 {
	if m != nil {
		return m.RssiMax
	}
	return 0
}

type AdsbPacket struct {
	// Unique value for the source that recorded this packet
	// UUID recommended
	// 36 character limit
	SourceId string `protobuf:"bytes,1,req,name=source_id" json:"source_id"`
	// Number of routing hops since source, when carried by protocols with a hop count.
	Hops uint32 `protobuf:"varint,2,req,name=hops" json:"hops"`
	// Value of the MLAT counter when this packet arrived at the recorder
	// Range [0, mlat_timestamp_max]
	// Units of 1 / (mlat_timestamp_mhz * 10^6) Hz
	MlatTimestamp uint64 `protobuf:"fixed64,3,opt,name=mlat_timestamp" json:"mlat_timestamp"`
	// RSSI of the received packet at the recorder
	// Range [0, rssi_max]
	// Units unspecified
	Rssi uint32 `protobuf:"fixed32,4,opt,name=rssi" json:"rssi"`
	// Binary packet payload.
	// Length:
	//   mode_ac: 2 bytes
	//   mode_s_short: 7 bytes
	//   mode_s_long: 14 bytes
	Payload []byte `protobuf:"bytes,5,req,name=payload" json:"payload"`
}

func (m *AdsbPacket) Reset()      { *m = AdsbPacket{} }
func (*AdsbPacket) ProtoMessage() {}

func (m *AdsbPacket) GetSourceId() string {
	if m != nil {
		return m.SourceId
	}
	return ""
}

func (m *AdsbPacket) GetHops() uint32 {
	if m != nil {
		return m.Hops
	}
	return 0
}

func (m *AdsbPacket) GetMlatTimestamp() uint64 {
	if m != nil {
		return m.MlatTimestamp
	}
	return 0
}

func (m *AdsbPacket) GetRssi() uint32 {
	if m != nil {
		return m.Rssi
	}
	return 0
}

func (m *AdsbPacket) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Adsb struct {
	// Each message must contain exactly one; zero is invalid.
	// The first record of a stream must be a header.
	// Subsequent records may be in any order, including additional headers.
	//
	// Types that are valid to be assigned to Record:
	//	*Adsb_Header
	//	*Adsb_ModeAc
	//	*Adsb_ModeSShort
	//	*Adsb_ModeSLong
	Record isAdsb_Record `protobuf_oneof:"record"`
}

func (m *Adsb) Reset()      { *m = Adsb{} }
func (*Adsb) ProtoMessage() {}

type isAdsb_Record interface {
	isAdsb_Record()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Adsb_Header struct {
	Header *AdsbHeader `protobuf:"bytes,1,opt,name=header,oneof"`
}
type Adsb_ModeAc struct {
	ModeAc *AdsbPacket `protobuf:"bytes,2,opt,name=mode_ac,oneof"`
}
type Adsb_ModeSShort struct {
	ModeSShort *AdsbPacket `protobuf:"bytes,3,opt,name=mode_s_short,oneof"`
}
type Adsb_ModeSLong struct {
	ModeSLong *AdsbPacket `protobuf:"bytes,4,opt,name=mode_s_long,oneof"`
}

func (*Adsb_Header) isAdsb_Record()     {}
func (*Adsb_ModeAc) isAdsb_Record()     {}
func (*Adsb_ModeSShort) isAdsb_Record() {}
func (*Adsb_ModeSLong) isAdsb_Record()  {}

func (m *Adsb) GetRecord() isAdsb_Record {
	if m != nil {
		return m.Record
	}
	return nil
}

func (m *Adsb) GetHeader() *AdsbHeader {
	if x, ok := m.GetRecord().(*Adsb_Header); ok {
		return x.Header
	}
	return nil
}

func (m *Adsb) GetModeAc() *AdsbPacket {
	if x, ok := m.GetRecord().(*Adsb_ModeAc); ok {
		return x.ModeAc
	}
	return nil
}

func (m *Adsb) GetModeSShort() *AdsbPacket {
	if x, ok := m.GetRecord().(*Adsb_ModeSShort); ok {
		return x.ModeSShort
	}
	return nil
}

func (m *Adsb) GetModeSLong() *AdsbPacket {
	if x, ok := m.GetRecord().(*Adsb_ModeSLong); ok {
		return x.ModeSLong
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Adsb) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Adsb_OneofMarshaler, _Adsb_OneofUnmarshaler, []interface{}{
		(*Adsb_Header)(nil),
		(*Adsb_ModeAc)(nil),
		(*Adsb_ModeSShort)(nil),
		(*Adsb_ModeSLong)(nil),
	}
}

func _Adsb_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Adsb)
	// record
	switch x := m.Record.(type) {
	case *Adsb_Header:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *Adsb_ModeAc:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ModeAc); err != nil {
			return err
		}
	case *Adsb_ModeSShort:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ModeSShort); err != nil {
			return err
		}
	case *Adsb_ModeSLong:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ModeSLong); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Adsb.Record has unexpected type %T", x)
	}
	return nil
}

func _Adsb_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Adsb)
	switch tag {
	case 1: // record.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdsbHeader)
		err := b.DecodeMessage(msg)
		m.Record = &Adsb_Header{msg}
		return true, err
	case 2: // record.mode_ac
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdsbPacket)
		err := b.DecodeMessage(msg)
		m.Record = &Adsb_ModeAc{msg}
		return true, err
	case 3: // record.mode_s_short
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdsbPacket)
		err := b.DecodeMessage(msg)
		m.Record = &Adsb_ModeSShort{msg}
		return true, err
	case 4: // record.mode_s_long
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdsbPacket)
		err := b.DecodeMessage(msg)
		m.Record = &Adsb_ModeSLong{msg}
		return true, err
	default:
		return false, nil
	}
}

// adsbus proto serialization takes advantage of the fact that an AdsbStream
// with many messages and many AdsbStreams each with a single message encode
// identically.
type AdsbStream struct {
	Msg []*Adsb `protobuf:"bytes,1,rep,name=msg" json:"msg,omitempty"`
}

func (m *AdsbStream) Reset()      { *m = AdsbStream{} }
func (*AdsbStream) ProtoMessage() {}

func (m *AdsbStream) GetMsg() []*Adsb {
	if m != nil {
		return m.Msg
	}
	return nil
}

func init() {
	proto.RegisterType((*AdsbHeader)(nil), "AdsbHeader")
	proto.RegisterType((*AdsbPacket)(nil), "AdsbPacket")
	proto.RegisterType((*Adsb)(nil), "Adsb")
	proto.RegisterType((*AdsbStream)(nil), "AdsbStream")
}
func (this *AdsbHeader) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AdsbHeader)
	if !ok {
		that2, ok := that.(AdsbHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Magic != that1.Magic {
		return false
	}
	if this.ServerVersion != that1.ServerVersion {
		return false
	}
	if this.ServerId != that1.ServerId {
		return false
	}
	if this.MlatTimestampMhz != that1.MlatTimestampMhz {
		return false
	}
	if this.MlatTimestampMax != that1.MlatTimestampMax {
		return false
	}
	if this.RssiMax != that1.RssiMax {
		return false
	}
	return true
}
func (this *AdsbPacket) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AdsbPacket)
	if !ok {
		that2, ok := that.(AdsbPacket)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SourceId != that1.SourceId {
		return false
	}
	if this.Hops != that1.Hops {
		return false
	}
	if this.MlatTimestamp != that1.MlatTimestamp {
		return false
	}
	if this.Rssi != that1.Rssi {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *Adsb) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Adsb)
	if !ok {
		that2, ok := that.(Adsb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Record == nil {
		if this.Record != nil {
			return false
		}
	} else if this.Record == nil {
		return false
	} else if !this.Record.Equal(that1.Record) {
		return false
	}
	return true
}
func (this *Adsb_Header) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Adsb_Header)
	if !ok {
		that2, ok := that.(Adsb_Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Header.Equal(that1.Header) {
		return false
	}
	return true
}
func (this *Adsb_ModeAc) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Adsb_ModeAc)
	if !ok {
		that2, ok := that.(Adsb_ModeAc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ModeAc.Equal(that1.ModeAc) {
		return false
	}
	return true
}
func (this *Adsb_ModeSShort) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Adsb_ModeSShort)
	if !ok {
		that2, ok := that.(Adsb_ModeSShort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ModeSShort.Equal(that1.ModeSShort) {
		return false
	}
	return true
}
func (this *Adsb_ModeSLong) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Adsb_ModeSLong)
	if !ok {
		that2, ok := that.(Adsb_ModeSLong)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ModeSLong.Equal(that1.ModeSLong) {
		return false
	}
	return true
}
func (this *AdsbStream) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AdsbStream)
	if !ok {
		that2, ok := that.(AdsbStream)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Msg) != len(that1.Msg) {
		return false
	}
	for i := range this.Msg {
		if !this.Msg[i].Equal(that1.Msg[i]) {
			return false
		}
	}
	return true
}
func (this *AdsbHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&adsb.AdsbHeader{")
	s = append(s, "Magic: "+fmt.Sprintf("%#v", this.Magic)+",\n")
	s = append(s, "ServerVersion: "+fmt.Sprintf("%#v", this.ServerVersion)+",\n")
	s = append(s, "ServerId: "+fmt.Sprintf("%#v", this.ServerId)+",\n")
	s = append(s, "MlatTimestampMhz: "+fmt.Sprintf("%#v", this.MlatTimestampMhz)+",\n")
	s = append(s, "MlatTimestampMax: "+fmt.Sprintf("%#v", this.MlatTimestampMax)+",\n")
	s = append(s, "RssiMax: "+fmt.Sprintf("%#v", this.RssiMax)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdsbPacket) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&adsb.AdsbPacket{")
	s = append(s, "SourceId: "+fmt.Sprintf("%#v", this.SourceId)+",\n")
	s = append(s, "Hops: "+fmt.Sprintf("%#v", this.Hops)+",\n")
	s = append(s, "MlatTimestamp: "+fmt.Sprintf("%#v", this.MlatTimestamp)+",\n")
	s = append(s, "Rssi: "+fmt.Sprintf("%#v", this.Rssi)+",\n")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Adsb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&adsb.Adsb{")
	if this.Record != nil {
		s = append(s, "Record: "+fmt.Sprintf("%#v", this.Record)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Adsb_Header) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&adsb.Adsb_Header{` +
		`Header:` + fmt.Sprintf("%#v", this.Header) + `}`}, ", ")
	return s
}
func (this *Adsb_ModeAc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&adsb.Adsb_ModeAc{` +
		`ModeAc:` + fmt.Sprintf("%#v", this.ModeAc) + `}`}, ", ")
	return s
}
func (this *Adsb_ModeSShort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&adsb.Adsb_ModeSShort{` +
		`ModeSShort:` + fmt.Sprintf("%#v", this.ModeSShort) + `}`}, ", ")
	return s
}
func (this *Adsb_ModeSLong) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&adsb.Adsb_ModeSLong{` +
		`ModeSLong:` + fmt.Sprintf("%#v", this.ModeSLong) + `}`}, ", ")
	return s
}
func (this *AdsbStream) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&adsb.AdsbStream{")
	if this.Msg != nil {
		s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAdsb(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringAdsb(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (m *AdsbHeader) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdsbHeader) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintAdsb(data, i, uint64(len(m.Magic)))
	i += copy(data[i:], m.Magic)
	data[i] = 0x12
	i++
	i = encodeVarintAdsb(data, i, uint64(len(m.ServerVersion)))
	i += copy(data[i:], m.ServerVersion)
	data[i] = 0x1a
	i++
	i = encodeVarintAdsb(data, i, uint64(len(m.ServerId)))
	i += copy(data[i:], m.ServerId)
	data[i] = 0x25
	i++
	i = encodeFixed32Adsb(data, i, uint32(m.MlatTimestampMhz))
	data[i] = 0x29
	i++
	i = encodeFixed64Adsb(data, i, uint64(m.MlatTimestampMax))
	data[i] = 0x35
	i++
	i = encodeFixed32Adsb(data, i, uint32(m.RssiMax))
	return i, nil
}

func (m *AdsbPacket) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdsbPacket) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintAdsb(data, i, uint64(len(m.SourceId)))
	i += copy(data[i:], m.SourceId)
	data[i] = 0x10
	i++
	i = encodeVarintAdsb(data, i, uint64(m.Hops))
	data[i] = 0x19
	i++
	i = encodeFixed64Adsb(data, i, uint64(m.MlatTimestamp))
	data[i] = 0x25
	i++
	i = encodeFixed32Adsb(data, i, uint32(m.Rssi))
	if m.Payload != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAdsb(data, i, uint64(len(m.Payload)))
		i += copy(data[i:], m.Payload)
	}
	return i, nil
}

func (m *Adsb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Adsb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Record != nil {
		nn1, err := m.Record.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *Adsb_Header) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Header != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAdsb(data, i, uint64(m.Header.Size()))
		n2, err := m.Header.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Adsb_ModeAc) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ModeAc != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAdsb(data, i, uint64(m.ModeAc.Size()))
		n3, err := m.ModeAc.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Adsb_ModeSShort) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ModeSShort != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAdsb(data, i, uint64(m.ModeSShort.Size()))
		n4, err := m.ModeSShort.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Adsb_ModeSLong) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ModeSLong != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAdsb(data, i, uint64(m.ModeSLong.Size()))
		n5, err := m.ModeSLong.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *AdsbStream) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdsbStream) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for _, msg := range m.Msg {
			data[i] = 0xa
			i++
			i = encodeVarintAdsb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Adsb(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Adsb(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAdsb(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *AdsbHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.Magic)
	n += 1 + l + sovAdsb(uint64(l))
	l = len(m.ServerVersion)
	n += 1 + l + sovAdsb(uint64(l))
	l = len(m.ServerId)
	n += 1 + l + sovAdsb(uint64(l))
	n += 5
	n += 9
	n += 5
	return n
}

func (m *AdsbPacket) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceId)
	n += 1 + l + sovAdsb(uint64(l))
	n += 1 + sovAdsb(uint64(m.Hops))
	n += 9
	n += 5
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}

func (m *Adsb) Size() (n int) {
	var l int
	_ = l
	if m.Record != nil {
		n += m.Record.Size()
	}
	return n
}

func (m *Adsb_Header) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}
func (m *Adsb_ModeAc) Size() (n int) {
	var l int
	_ = l
	if m.ModeAc != nil {
		l = m.ModeAc.Size()
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}
func (m *Adsb_ModeSShort) Size() (n int) {
	var l int
	_ = l
	if m.ModeSShort != nil {
		l = m.ModeSShort.Size()
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}
func (m *Adsb_ModeSLong) Size() (n int) {
	var l int
	_ = l
	if m.ModeSLong != nil {
		l = m.ModeSLong.Size()
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}
func (m *AdsbStream) Size() (n int) {
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for _, e := range m.Msg {
			l = e.Size()
			n += 1 + l + sovAdsb(uint64(l))
		}
	}
	return n
}

func sovAdsb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAdsb(x uint64) (n int) {
	return sovAdsb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AdsbHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdsbHeader{`,
		`Magic:` + fmt.Sprintf("%v", this.Magic) + `,`,
		`ServerVersion:` + fmt.Sprintf("%v", this.ServerVersion) + `,`,
		`ServerId:` + fmt.Sprintf("%v", this.ServerId) + `,`,
		`MlatTimestampMhz:` + fmt.Sprintf("%v", this.MlatTimestampMhz) + `,`,
		`MlatTimestampMax:` + fmt.Sprintf("%v", this.MlatTimestampMax) + `,`,
		`RssiMax:` + fmt.Sprintf("%v", this.RssiMax) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdsbPacket) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdsbPacket{`,
		`SourceId:` + fmt.Sprintf("%v", this.SourceId) + `,`,
		`Hops:` + fmt.Sprintf("%v", this.Hops) + `,`,
		`MlatTimestamp:` + fmt.Sprintf("%v", this.MlatTimestamp) + `,`,
		`Rssi:` + fmt.Sprintf("%v", this.Rssi) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Adsb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Adsb{`,
		`Record:` + fmt.Sprintf("%v", this.Record) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Adsb_Header) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Adsb_Header{`,
		`Header:` + strings.Replace(fmt.Sprintf("%v", this.Header), "AdsbHeader", "AdsbHeader", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Adsb_ModeAc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Adsb_ModeAc{`,
		`ModeAc:` + strings.Replace(fmt.Sprintf("%v", this.ModeAc), "AdsbPacket", "AdsbPacket", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Adsb_ModeSShort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Adsb_ModeSShort{`,
		`ModeSShort:` + strings.Replace(fmt.Sprintf("%v", this.ModeSShort), "AdsbPacket", "AdsbPacket", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Adsb_ModeSLong) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Adsb_ModeSLong{`,
		`ModeSLong:` + strings.Replace(fmt.Sprintf("%v", this.ModeSLong), "AdsbPacket", "AdsbPacket", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdsbStream) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdsbStream{`,
		`Msg:` + strings.Replace(fmt.Sprintf("%v", this.Msg), "Adsb", "Adsb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAdsb(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AdsbHeader) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdsbHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdsbHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Magic = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MlatTimestampMhz", wireType)
			}
			m.MlatTimestampMhz = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.MlatTimestampMhz = uint32(data[iNdEx-4])
			m.MlatTimestampMhz |= uint32(data[iNdEx-3]) << 8
			m.MlatTimestampMhz |= uint32(data[iNdEx-2]) << 16
			m.MlatTimestampMhz |= uint32(data[iNdEx-1]) << 24
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MlatTimestampMax", wireType)
			}
			m.MlatTimestampMax = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.MlatTimestampMax = uint64(data[iNdEx-8])
			m.MlatTimestampMax |= uint64(data[iNdEx-7]) << 8
			m.MlatTimestampMax |= uint64(data[iNdEx-6]) << 16
			m.MlatTimestampMax |= uint64(data[iNdEx-5]) << 24
			m.MlatTimestampMax |= uint64(data[iNdEx-4]) << 32
			m.MlatTimestampMax |= uint64(data[iNdEx-3]) << 40
			m.MlatTimestampMax |= uint64(data[iNdEx-2]) << 48
			m.MlatTimestampMax |= uint64(data[iNdEx-1]) << 56
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RssiMax", wireType)
			}
			m.RssiMax = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.RssiMax = uint32(data[iNdEx-4])
			m.RssiMax |= uint32(data[iNdEx-3]) << 8
			m.RssiMax |= uint32(data[iNdEx-2]) << 16
			m.RssiMax |= uint32(data[iNdEx-1]) << 24
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipAdsb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdsb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("magic")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("server_version")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("server_id")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("mlat_timestamp_mhz")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("mlat_timestamp_max")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("rssi_max")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdsbPacket) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdsbPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdsbPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hops", wireType)
			}
			m.Hops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Hops |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MlatTimestamp", wireType)
			}
			m.MlatTimestamp = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.MlatTimestamp = uint64(data[iNdEx-8])
			m.MlatTimestamp |= uint64(data[iNdEx-7]) << 8
			m.MlatTimestamp |= uint64(data[iNdEx-6]) << 16
			m.MlatTimestamp |= uint64(data[iNdEx-5]) << 24
			m.MlatTimestamp |= uint64(data[iNdEx-4]) << 32
			m.MlatTimestamp |= uint64(data[iNdEx-3]) << 40
			m.MlatTimestamp |= uint64(data[iNdEx-2]) << 48
			m.MlatTimestamp |= uint64(data[iNdEx-1]) << 56
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			m.Rssi = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Rssi = uint32(data[iNdEx-4])
			m.Rssi |= uint32(data[iNdEx-3]) << 8
			m.Rssi |= uint32(data[iNdEx-2]) << 16
			m.Rssi |= uint32(data[iNdEx-1]) << 24
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], data[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipAdsb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdsb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("source_id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("hops")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("payload")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Adsb) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Adsb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Adsb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdsbHeader{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Record = &Adsb_Header{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeAc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdsbPacket{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Record = &Adsb_ModeAc{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeSShort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdsbPacket{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Record = &Adsb_ModeSShort{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeSLong", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdsbPacket{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Record = &Adsb_ModeSLong{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdsb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdsb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdsbStream) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdsbStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdsbStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg, &Adsb{})
			if err := m.Msg[len(m.Msg)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdsb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdsb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdsb(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAdsb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAdsb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAdsb(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAdsb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdsb   = fmt.Errorf("proto: integer overflow")
)
