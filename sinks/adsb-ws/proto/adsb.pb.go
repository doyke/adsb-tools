// Code generated by protoc-gen-gogo.
// source: proto/adsb.proto
// DO NOT EDIT!

/*
	Package adsb is a generated protocol buffer package.

	It is generated from these files:
		proto/adsb.proto

	It has these top-level messages:
		AdsbHeader
		AdsbPacket
		Adsb
		AdsbStream
*/
package adsb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AdsbHeader struct {
	// Always "aDsB"
	Magic *string `protobuf:"bytes,1,req,name=magic" json:"magic,omitempty"`
	// Unique identifier for this server implementation
	// Recommended: "https://url/of/source#version"
	ServerVersion *string `protobuf:"bytes,2,req,name=server_version" json:"server_version,omitempty"`
	// Unique identifier for this server instance
	// UUID recommended
	// 36 character limit
	ServerId *string `protobuf:"bytes,3,req,name=server_id" json:"server_id,omitempty"`
	// MHz of the clock used in subsequent mlat_timestamp fields
	MlatTimestampMhz *uint32 `protobuf:"fixed32,4,req,name=mlat_timestamp_mhz" json:"mlat_timestamp_mhz,omitempty"`
	// Maximum value of subsequent mlat_timestamp fields, at which point values are expected to wrap
	MlatTimestampMax *uint64 `protobuf:"fixed64,5,req,name=mlat_timestamp_max" json:"mlat_timestamp_max,omitempty"`
	// Maximum value of subsequent rssi fields
	RssiMax          *uint32 `protobuf:"fixed32,6,req,name=rssi_max" json:"rssi_max,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AdsbHeader) Reset()         { *m = AdsbHeader{} }
func (m *AdsbHeader) String() string { return proto.CompactTextString(m) }
func (*AdsbHeader) ProtoMessage()    {}

func (m *AdsbHeader) GetMagic() string {
	if m != nil && m.Magic != nil {
		return *m.Magic
	}
	return ""
}

func (m *AdsbHeader) GetServerVersion() string {
	if m != nil && m.ServerVersion != nil {
		return *m.ServerVersion
	}
	return ""
}

func (m *AdsbHeader) GetServerId() string {
	if m != nil && m.ServerId != nil {
		return *m.ServerId
	}
	return ""
}

func (m *AdsbHeader) GetMlatTimestampMhz() uint32 {
	if m != nil && m.MlatTimestampMhz != nil {
		return *m.MlatTimestampMhz
	}
	return 0
}

func (m *AdsbHeader) GetMlatTimestampMax() uint64 {
	if m != nil && m.MlatTimestampMax != nil {
		return *m.MlatTimestampMax
	}
	return 0
}

func (m *AdsbHeader) GetRssiMax() uint32 {
	if m != nil && m.RssiMax != nil {
		return *m.RssiMax
	}
	return 0
}

type AdsbPacket struct {
	// Unique value for the source that recorded this packet
	// UUID recommended
	// 36 character limit
	SourceId *string `protobuf:"bytes,1,req,name=source_id" json:"source_id,omitempty"`
	// Number of routing hops since source, when carried by protocols with a hop count.
	Hops *uint32 `protobuf:"varint,2,req,name=hops" json:"hops,omitempty"`
	// Value of the MLAT counter when this packet arrived at the recorder
	// Range [0, mlat_timestamp_max]
	// Units of 1 / (mlat_timestamp_mhz * 10^6) Hz
	MlatTimestamp *uint64 `protobuf:"fixed64,3,opt,name=mlat_timestamp" json:"mlat_timestamp,omitempty"`
	// RSSI of the received packet at the recorder
	// Range [0, rssi_max]
	// Units unspecified
	Rssi *uint32 `protobuf:"fixed32,4,opt,name=rssi" json:"rssi,omitempty"`
	// Binary packet payload.
	// Length:
	//   mode_ac: 2 bytes
	//   mode_s_short: 7 bytes
	//   mode_s_long: 14 bytes
	Payload          []byte `protobuf:"bytes,5,req,name=payload" json:"payload,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AdsbPacket) Reset()         { *m = AdsbPacket{} }
func (m *AdsbPacket) String() string { return proto.CompactTextString(m) }
func (*AdsbPacket) ProtoMessage()    {}

func (m *AdsbPacket) GetSourceId() string {
	if m != nil && m.SourceId != nil {
		return *m.SourceId
	}
	return ""
}

func (m *AdsbPacket) GetHops() uint32 {
	if m != nil && m.Hops != nil {
		return *m.Hops
	}
	return 0
}

func (m *AdsbPacket) GetMlatTimestamp() uint64 {
	if m != nil && m.MlatTimestamp != nil {
		return *m.MlatTimestamp
	}
	return 0
}

func (m *AdsbPacket) GetRssi() uint32 {
	if m != nil && m.Rssi != nil {
		return *m.Rssi
	}
	return 0
}

func (m *AdsbPacket) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Adsb struct {
	// Each message must contain exactly one; zero is invalid.
	// The first record of a stream must be a header.
	// Subsequent records may be in any order, including additional headers.
	//
	// Types that are valid to be assigned to Record:
	//	*Adsb_Header
	//	*Adsb_ModeAc
	//	*Adsb_ModeSShort
	//	*Adsb_ModeSLong
	Record           isAdsb_Record `protobuf_oneof:"record"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Adsb) Reset()         { *m = Adsb{} }
func (m *Adsb) String() string { return proto.CompactTextString(m) }
func (*Adsb) ProtoMessage()    {}

type isAdsb_Record interface {
	isAdsb_Record()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Adsb_Header struct {
	Header *AdsbHeader `protobuf:"bytes,1,opt,name=header,oneof"`
}
type Adsb_ModeAc struct {
	ModeAc *AdsbPacket `protobuf:"bytes,2,opt,name=mode_ac,oneof"`
}
type Adsb_ModeSShort struct {
	ModeSShort *AdsbPacket `protobuf:"bytes,3,opt,name=mode_s_short,oneof"`
}
type Adsb_ModeSLong struct {
	ModeSLong *AdsbPacket `protobuf:"bytes,4,opt,name=mode_s_long,oneof"`
}

func (*Adsb_Header) isAdsb_Record()     {}
func (*Adsb_ModeAc) isAdsb_Record()     {}
func (*Adsb_ModeSShort) isAdsb_Record() {}
func (*Adsb_ModeSLong) isAdsb_Record()  {}

func (m *Adsb) GetRecord() isAdsb_Record {
	if m != nil {
		return m.Record
	}
	return nil
}

func (m *Adsb) GetHeader() *AdsbHeader {
	if x, ok := m.GetRecord().(*Adsb_Header); ok {
		return x.Header
	}
	return nil
}

func (m *Adsb) GetModeAc() *AdsbPacket {
	if x, ok := m.GetRecord().(*Adsb_ModeAc); ok {
		return x.ModeAc
	}
	return nil
}

func (m *Adsb) GetModeSShort() *AdsbPacket {
	if x, ok := m.GetRecord().(*Adsb_ModeSShort); ok {
		return x.ModeSShort
	}
	return nil
}

func (m *Adsb) GetModeSLong() *AdsbPacket {
	if x, ok := m.GetRecord().(*Adsb_ModeSLong); ok {
		return x.ModeSLong
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Adsb) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Adsb_OneofMarshaler, _Adsb_OneofUnmarshaler, []interface{}{
		(*Adsb_Header)(nil),
		(*Adsb_ModeAc)(nil),
		(*Adsb_ModeSShort)(nil),
		(*Adsb_ModeSLong)(nil),
	}
}

func _Adsb_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Adsb)
	// record
	switch x := m.Record.(type) {
	case *Adsb_Header:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *Adsb_ModeAc:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ModeAc); err != nil {
			return err
		}
	case *Adsb_ModeSShort:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ModeSShort); err != nil {
			return err
		}
	case *Adsb_ModeSLong:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ModeSLong); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Adsb.Record has unexpected type %T", x)
	}
	return nil
}

func _Adsb_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Adsb)
	switch tag {
	case 1: // record.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdsbHeader)
		err := b.DecodeMessage(msg)
		m.Record = &Adsb_Header{msg}
		return true, err
	case 2: // record.mode_ac
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdsbPacket)
		err := b.DecodeMessage(msg)
		m.Record = &Adsb_ModeAc{msg}
		return true, err
	case 3: // record.mode_s_short
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdsbPacket)
		err := b.DecodeMessage(msg)
		m.Record = &Adsb_ModeSShort{msg}
		return true, err
	case 4: // record.mode_s_long
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdsbPacket)
		err := b.DecodeMessage(msg)
		m.Record = &Adsb_ModeSLong{msg}
		return true, err
	default:
		return false, nil
	}
}

// adsbus proto serialization takes advantage of the fact that an AdsbStream
// with many messages and many AdsbStreams each with a single message encode
// identically.
type AdsbStream struct {
	Msg              []*Adsb `protobuf:"bytes,1,rep,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AdsbStream) Reset()         { *m = AdsbStream{} }
func (m *AdsbStream) String() string { return proto.CompactTextString(m) }
func (*AdsbStream) ProtoMessage()    {}

func (m *AdsbStream) GetMsg() []*Adsb {
	if m != nil {
		return m.Msg
	}
	return nil
}

func init() {
	proto.RegisterType((*AdsbHeader)(nil), "AdsbHeader")
	proto.RegisterType((*AdsbPacket)(nil), "AdsbPacket")
	proto.RegisterType((*Adsb)(nil), "Adsb")
	proto.RegisterType((*AdsbStream)(nil), "AdsbStream")
}
func (m *AdsbHeader) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdsbHeader) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Magic == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintAdsb(data, i, uint64(len(*m.Magic)))
		i += copy(data[i:], *m.Magic)
	}
	if m.ServerVersion == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintAdsb(data, i, uint64(len(*m.ServerVersion)))
		i += copy(data[i:], *m.ServerVersion)
	}
	if m.ServerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x1a
		i++
		i = encodeVarintAdsb(data, i, uint64(len(*m.ServerId)))
		i += copy(data[i:], *m.ServerId)
	}
	if m.MlatTimestampMhz == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x25
		i++
		i = encodeFixed32Adsb(data, i, uint32(*m.MlatTimestampMhz))
	}
	if m.MlatTimestampMax == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x29
		i++
		i = encodeFixed64Adsb(data, i, uint64(*m.MlatTimestampMax))
	}
	if m.RssiMax == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x35
		i++
		i = encodeFixed32Adsb(data, i, uint32(*m.RssiMax))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdsbPacket) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdsbPacket) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintAdsb(data, i, uint64(len(*m.SourceId)))
		i += copy(data[i:], *m.SourceId)
	}
	if m.Hops == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x10
		i++
		i = encodeVarintAdsb(data, i, uint64(*m.Hops))
	}
	if m.MlatTimestamp != nil {
		data[i] = 0x19
		i++
		i = encodeFixed64Adsb(data, i, uint64(*m.MlatTimestamp))
	}
	if m.Rssi != nil {
		data[i] = 0x25
		i++
		i = encodeFixed32Adsb(data, i, uint32(*m.Rssi))
	}
	if m.Payload == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x2a
		i++
		i = encodeVarintAdsb(data, i, uint64(len(m.Payload)))
		i += copy(data[i:], m.Payload)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Adsb) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Adsb) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Record != nil {
		nn1, err := m.Record.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Adsb_Header) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Header != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAdsb(data, i, uint64(m.Header.Size()))
		n2, err := m.Header.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Adsb_ModeAc) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ModeAc != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAdsb(data, i, uint64(m.ModeAc.Size()))
		n3, err := m.ModeAc.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Adsb_ModeSShort) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ModeSShort != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAdsb(data, i, uint64(m.ModeSShort.Size()))
		n4, err := m.ModeSShort.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Adsb_ModeSLong) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ModeSLong != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAdsb(data, i, uint64(m.ModeSLong.Size()))
		n5, err := m.ModeSLong.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *AdsbStream) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdsbStream) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for _, msg := range m.Msg {
			data[i] = 0xa
			i++
			i = encodeVarintAdsb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Adsb(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Adsb(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAdsb(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *AdsbHeader) Size() (n int) {
	var l int
	_ = l
	if m.Magic != nil {
		l = len(*m.Magic)
		n += 1 + l + sovAdsb(uint64(l))
	}
	if m.ServerVersion != nil {
		l = len(*m.ServerVersion)
		n += 1 + l + sovAdsb(uint64(l))
	}
	if m.ServerId != nil {
		l = len(*m.ServerId)
		n += 1 + l + sovAdsb(uint64(l))
	}
	if m.MlatTimestampMhz != nil {
		n += 5
	}
	if m.MlatTimestampMax != nil {
		n += 9
	}
	if m.RssiMax != nil {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdsbPacket) Size() (n int) {
	var l int
	_ = l
	if m.SourceId != nil {
		l = len(*m.SourceId)
		n += 1 + l + sovAdsb(uint64(l))
	}
	if m.Hops != nil {
		n += 1 + sovAdsb(uint64(*m.Hops))
	}
	if m.MlatTimestamp != nil {
		n += 9
	}
	if m.Rssi != nil {
		n += 5
	}
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovAdsb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Adsb) Size() (n int) {
	var l int
	_ = l
	if m.Record != nil {
		n += m.Record.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Adsb_Header) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}
func (m *Adsb_ModeAc) Size() (n int) {
	var l int
	_ = l
	if m.ModeAc != nil {
		l = m.ModeAc.Size()
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}
func (m *Adsb_ModeSShort) Size() (n int) {
	var l int
	_ = l
	if m.ModeSShort != nil {
		l = m.ModeSShort.Size()
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}
func (m *Adsb_ModeSLong) Size() (n int) {
	var l int
	_ = l
	if m.ModeSLong != nil {
		l = m.ModeSLong.Size()
		n += 1 + l + sovAdsb(uint64(l))
	}
	return n
}
func (m *AdsbStream) Size() (n int) {
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for _, e := range m.Msg {
			l = e.Size()
			n += 1 + l + sovAdsb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAdsb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAdsb(x uint64) (n int) {
	return sovAdsb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AdsbHeader) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdsbHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdsbHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Magic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Magic = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ServerVersion = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ServerId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MlatTimestampMhz", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.MlatTimestampMhz = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MlatTimestampMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.MlatTimestampMax = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RssiMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.RssiMax = &v
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipAdsb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdsb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdsbPacket) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdsbPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdsbPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SourceId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hops", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hops = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MlatTimestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.MlatTimestamp = &v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Rssi = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], data[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipAdsb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdsb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Adsb) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Adsb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Adsb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdsbHeader{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Record = &Adsb_Header{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeAc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdsbPacket{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Record = &Adsb_ModeAc{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeSShort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdsbPacket{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Record = &Adsb_ModeSShort{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeSLong", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdsbPacket{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Record = &Adsb_ModeSLong{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdsb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdsb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdsbStream) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdsbStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdsbStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdsb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg, &Adsb{})
			if err := m.Msg[len(m.Msg)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdsb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdsb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdsb(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdsb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdsb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAdsb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAdsb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAdsb(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAdsb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdsb   = fmt.Errorf("proto: integer overflow")
)
